{"version":3,"sources":["components/Rules.tsx","assets/CGOL.gif","components/LandingPage.tsx","components/Board.tsx","components/Game.tsx","App.tsx","tests/reportWebVitals.ts","index.tsx"],"names":["Rules","styled","className","LandingPage","history","useHistory","StyledImg","width","height","objectFit","StyledText","position","top","left","transform","color","fontSize","src","CGOLGIF","onClick","event","preventDefault","push","Board","props","operations","StyledGame","display","justifyContent","alignItems","StyledGrid","gridTemplateColumns","padding","placeItems","backgroundColor","StyledCell","border","margin","useState","rows","i","Array","from","grid","setGrid","running","setRunning","runRef","useRef","current","runSim","useCallback","g","produce","gridCopy","j","neighbours","forEach","x","y","newI","newJ","setTimeout","map","newGrid","Game","App","exact","path","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.b191afcf.chunk.js","sourcesContent":["import React from 'react';\nimport {styled} from '@stitches/react';\nfunction Rules(){\n\n    const div = styled('div',{\n        '.rulesContainer': {\n            \n        }\n    })\n\n\n    return (\n    <div className=\"rulesContainer\">\n        <h2>Rules:</h2>\n        <p>\n          The universe of the Game of Life is an infinite, two-dimensional\n          orthogonal grid of square cells, each of which is in one of two\n          possible states, live or dead, (or populated and unpopulated,\n          respectively). Every cell interacts with its eight neighbours, which\n          are the cells that are horizontally, vertically, or diagonally\n          adjacent. At each step in time, the following transitions occur:\n        </p>\n        <ul>\n          <li>\n            Any live cell with fewer than two live neighbours dies, as if by\n            underpopulation.\n          </li>\n          <li>\n            Any live cell with two or three live neighbours lives on to the next\n            generation.\n          </li>\n          <li>\n            Any live cell with more than three live neighbours dies, as if by\n            overpopulation.\n          </li>\n          <li>\n            Any dead cell with exactly three live neighbours becomes a live\n            cell, as if by reproduction.\n          </li>\n        </ul>\n        <p>\n          These rules, which compare the behavior of the automaton to real life,\n          can be condensed into the following:\n        </p>\n        <ul>\n          <li>Any live cell with two or three live neighbours survives.</li>\n          <li>Any dead cell with three live neighbours becomes a live cell.</li>\n          <li>\n            All other live cells die in the next generation. Similarly, all\n            other dead cells stay dead.\n          </li>\n        </ul>\n        <p>\n          The initial pattern constitutes the seed of the system. The first\n          generation is created by applying the above rules simultaneously to\n          every cell in the seed; births and deaths occur simultaneously, and\n          the discrete moment at which this happens is sometimes called a tick.\n          Each generation is a pure function of the preceding one. The rules\n          continue to be applied repeatedly to create further generations.\n        </p>\n        <p>Additional custom rules:</p>\n        <ul>\n          <li>\n            Random Mode: By toggling random mode to true, you disable to\n            infinite life capabilities of the game. A random number generator is\n            used to determine how the game will behave for the next generation.\n            There is a chance of an overwhelming amount of life, or overwhelming\n            amount of death.\n          </li>\n        </ul>\n      </div>\n    )\n}\nexport default Rules","export default __webpack_public_path__ + \"static/media/CGOL.58f64f84.gif\";","import React from 'react';\nimport { styled } from '@stitches/react';\nimport CGOLGIF from '../assets/CGOL.gif';\nimport { useHistory } from 'react-router-dom';\n\n\nfunction LandingPage() {\n    const history = useHistory()\n    const StyledImg = styled('img', {\n        width: '100%',\n        height: '100vh',\n        objectFit: 'cover',\n    })\n\n    const StyledText = styled('div', {\n        position: 'absolute',\n        top: '50%',\n        left: '50%',\n        transform: 'translate(-50%, -50%);',\n        color: 'white',\n        fontSize: '1rem'\n    })\n\n    const pushToGame = (event: React.MouseEvent) => {\n        event?.preventDefault();\n        history.push('/game')\n    }\n\n    return (\n        <>\n            <StyledImg src={CGOLGIF} />\n            <StyledText>\n                Welcome to Sebastian's Game of Life!\n                <br></br>\n                <button onClick={pushToGame}> Play!</button>\n            </StyledText>\n        </>\n    )\n}\nexport default LandingPage","import React, { useCallback, useState, useRef } from 'react';\nimport { styled } from '@stitches/react';\nimport produce from 'immer';\n\n\nfunction Board(props: any) {\n\n    const numRows = 25;\n    const numCols = 25;\n    const operations = [\n        [0, 1],\n        [0, -1],\n        [1, -1],\n        [-1, 1],\n        [1, 1],\n        [-1, -1],\n        [1, 0],\n        [-1, 0]\n    ];\n\n\n    const StyledGame = styled('div', {\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center'\n    })\n\n\n    const StyledGrid = styled('div', {\n        display: 'grid',\n        gridTemplateColumns: `repeat(${numCols},20px)`,\n        padding: '20px',\n        placeItems: 'center',\n        backgroundColor: 'dodgerblue',\n    })\n\n    const StyledCell = styled('div', {\n        width: '20px',\n        height: '20px',\n        border: 'solid 2px black',\n        margin: '1px',\n        '&.dead': {\n            backgroundColor: 'white',\n        },\n        '&.alive': {\n            backgroundColor: 'black',\n        }\n    })\n    const [grid, setGrid] = useState(() => {\n        const rows = [];\n        for (let i = 0; i < numRows; i++) {\n            rows.push(Array.from(Array(numCols), () => 0))\n        }\n        return rows\n    })\n\n\n    const [running, setRunning] = useState(false)\n\n    const runRef = useRef(running);\n    runRef.current = running\n\n    const runSim = useCallback(() => {\n        if (!runRef.current) {\n            return\n        }\n        \n        setGrid(g => {\n            return produce(g, gridCopy => {\n                for (let i = 0; i < numRows; i++) {\n                    for (let j = 0; j < numCols; j++) {\n                        let neighbours = 0;\n                        operations.forEach(([x, y]) => {\n                            const newI = i + x\n                            const newJ = j + y\n                            if (newI >= 0 && newI < numRows && newJ >= 0 && newJ < numCols) {\n                                neighbours += g[newI][newJ]\n                            }\n                        })\n\n                            if (neighbours < 2 || neighbours > 3) {\n                                gridCopy[i][j] = 0\n                            } else if (g[i][j] === 0 && neighbours === 3) {\n                                gridCopy[i][j] = 1;\n                            }\n                        }\n                    }\n                })\n            })\n        \n        setTimeout(runSim, 100)\n    }, [])\n\n\n    return (\n        <StyledGame>\n            <button onClick={() => {\n                setRunning(!running)\n                if (!running) {\n                    runRef.current = true\n                    runSim()\n                }\n            }}\n\n            >\n                {running ? 'stop' : 'start'}\n            </button>\n            <StyledGrid>\n                {\n                    grid.map((x, i) => (\n                        x.map((y, j) =>\n                        (\n                            <StyledCell\n                                onClick={() => {\n                                    const newGrid = produce(grid, gridCopy => {\n                                        gridCopy[i][j] = grid[i][j] ? 0 : 1;\n                                    })\n                                    setGrid((newGrid))\n                                }}\n                                key={`${i}-${j}`}\n                                className={y === 0 ? 'dead' : 'alive'} />\n                        )\n                        )\n                    ))\n                }\n            </StyledGrid>\n        </StyledGame>\n    );\n}\n\nexport default Board","import React, { useState } from 'react';\nimport Board from './Board';\nimport { styled } from '@stitches/react';\n\n\n\nfunction Game(props: any) {\n\n    return (\n        <>\n            <Board/>            \n        </>\n    )\n}\n\nexport default Game","import React from 'react';\nimport './styling/App.css';\nimport Rules from './components/Rules';\nimport LandingPage from './components/LandingPage';\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n} from \"react-router-dom\";\nimport Game from './components/Game';\n\nfunction App() {\n  return (\n    <>\n      <Router>\n        <Switch>\n          <Route exact path=\"/\">\n            <LandingPage />\n          </Route>\n          <Route path=\"/rules\">\n            <Rules />\n          </Route>\n          <Route path=\"/game\">\n            <Game/>\n          </Route>\n        </Switch>\n      </Router>\n    </>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './styling/index.css';\nimport App from './App';\nimport reportWebVitals from './tests/reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}